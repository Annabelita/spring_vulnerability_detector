/*
 * Starter Class  */

package com.pama;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import org.json.JSONException;
import org.slf4j.Logger;

import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import document.Vulnerability;
import resource.VulnerabilityService;
import synchronization.Synchronization;

@SpringBootApplication(scanBasePackages = { "config", "document", "repository", "resource", "com.pama" })
public class SchwachstellenDetektorApplication implements CommandLineRunner {

	private static VulnerabilityService vulService;

	private static final Logger LOG = LoggerFactory.getLogger("Vulnerability");

	@Autowired
	public SchwachstellenDetektorApplication(VulnerabilityService vulService) {
		SchwachstellenDetektorApplication.vulService = vulService;
	}

	public static void main(String[] args) {
		SpringApplication.run(SchwachstellenDetektorApplication.class, args);

	}

	@Override
	public void run(String... args) throws JsonProcessingException, JSONException, IOException {

		/* ----------------------------- LOKALE DB SETUP --------------------------- */
		// diese Methoden werden bei Start der Anwendung aufgerufen

		Synchronization.setupDatabase(false); 	// Aufsetzen der Datenbank mit false als Kennzeichen für das Starten der Anwendung
		Synchronization.startTimer();			// starte den Timer für die automatische Synchronisation
		System.out.println("----------Application erfolgreich geladen!");

		/*
		 * -------------------------------------- ENDE DB SETUP
		 * --------------------------------------
		 */

	}

	/*
	 * Parses the JSON-Feed
	 * 
	 * Saves all CVE-Objects in a HashMap<Integer, JsonNode> datastructure Extracts
	 * the following properties from each CVE-Object: - ID - vendor name - product
	 * name - version - description - cpe value - last-modified-date -
	 * published-date
	 */

	public static void parseJSON(String filename) throws JsonProcessingException, JSONException, IOException {

		byte[] jsonData = Files.readAllBytes(Paths.get(filename));
		HashMap<Integer, JsonNode> myHashMap = new HashMap<Integer, JsonNode>();
		HashMap<Integer, Vulnerability> hashMap = new HashMap<Integer, Vulnerability>();
		ObjectMapper mapper = new ObjectMapper();
		JsonNode rootNode = mapper.readTree(jsonData);

		int key;
		JsonNode value;

		// Get all CVE-Objects
		for (int h = 0; h < rootNode.get("CVE_Items").size(); h++) {
			key = h;
			value = rootNode.get("CVE_Items").get(h);
			myHashMap.put(key, value);

		}

		// Get all Object-Attributes
		for (Integer name : myHashMap.keySet()) {

			Vulnerability vul = new Vulnerability();
			JsonNode values = myHashMap.get(name);

			vul.setId(values.findValue("ID").toString());

			if (values.findValue("vendor_name") != null) {
				vul.setVendor_name(values.findValue("vendor_name").toString());
			} else {
				continue;
			}

			if (values.findValue("product_name") != null) {
				vul.setProduct_name(values.findValue("product_name").toString());
			} else {
				continue;
			}

			if (values.findValue("version_data") != null) {
				int size = values.findValue("version_data").size();

				String[] vals = new String[size];
				String temp;
				JsonNode versions = values.findValue("version_data");
				int counter = 0;

				for (JsonNode version : versions) {
					temp = "";
					temp = version.get("version_value").toString().replace("\"", "");

					if (temp.equals("-")) {
						continue;
					} else {
						vals[counter] = temp;
						counter++;
					}
				}
				vul.setVersion_value(vals);

			} else {
				continue;
			}
			vul.setProblem_value(values.findValue("description_data").findValue("value").toString());
			vul.setLastModified(values.findValue("lastModifiedDate").toString());
			vul.setPublishDate(values.findValue("publishedDate").toString());

			hashMap.put(name, vul);

			// prüfe, ob eine veraltete Schwachstelle mit der gleichen ID existiert und lösche sie
			Vulnerability check = vulService.findOneById(vul.id);
			if (check != null) {
				vulService.deleteVul(check);
			}

			vulService.saveVul(vul);

		}

	}

}
