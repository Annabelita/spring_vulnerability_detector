/*
 * MVC: Main View Controller
 */

package com.pama;

import java.io.IOException;

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import javax.servlet.http.HttpServletRequest;
import repository.VulnerabiltyMongoRepository;
import resource.VulnerabilityService;
import synchronization.Synchronization;
import org.json.JSONException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import com.fasterxml.jackson.core.JsonProcessingException;
import document.Vulnerability;
import matching.NGram;
import operatingSystem.Detector;

@Controller
public class MainController {

	private final VulnerabilityService vulService;

	@Autowired
	public MainController(VulnerabilityService vulService) {
		this.vulService = vulService;
	}

	@Autowired
	private VulnerabiltyMongoRepository vulRepo;

	// ------------- Index ---------------------
	@RequestMapping("/")
	public String indexnoName() {
		return "index";
	}

	@RequestMapping(value = "/index", method = RequestMethod.POST)
	public String postindex() {
		return "index";
	}

	// ------------- Suche ---------------------
	@RequestMapping("/suche")
	public String suchenoName() {
		return "suche";
	}

	@RequestMapping(value = "/suche", method = RequestMethod.POST)
	public String postsuche() {
		return "suche";
	}

	// ------------- Detektion ---------------------
	@RequestMapping("/detektion")
	public String detektionnoName() {
		return "detektion";
	}

	@RequestMapping("/ergebnisDetektion")
	public String ergebnisDetektion() {
		return "ergebnisDetektion";
	}

	// löst Detektion aus
	@RequestMapping(value = "/ergebnisDetektion", method = RequestMethod.POST)
	public String postdetektion(Model model) throws IOException {

		List<Vulnerability> vulList = new ArrayList<Vulnerability>();
		Detector detector = new Detector(vulService);
		vulList = detector.detect();

		if (vulList.isEmpty()) {
			return "keinErgebnisDetektor";
		}
		model.addAttribute("vuls", vulList);

		return "ergebnisDetektion";
	}

	// ------------- DB Aktualisierung ---------------------
	@RequestMapping("/dbAktualisiert")
	public String dbAktualisiertnoName() {
		return "dbAktualisiert";
	}

	@RequestMapping(value = "/dbAktualisiert", method = RequestMethod.POST)
	public String postdbAktualisiert() throws JsonProcessingException, JSONException, IOException {
		Synchronization.setupDatabase(true);
		return "dbAktualisiert";
	}

	// ------------- Redirect zur detailseite ---------------------
	@RequestMapping("/detailseite")
	public String detailseitenoName() {
		return "detailseite";
	}

	@RequestMapping(value = "/detailseite", method = RequestMethod.POST)
	public String postdetailseite() {
		return "detailseite";
	}

	// ------------- Ergebnis ---------------------
	@RequestMapping(value = "/index", method = RequestMethod.GET)
	public String getindex() {
		return "index";
	}

	// Methode für die manuelle Suche
	@RequestMapping(value = "/ergebnis", method = RequestMethod.POST)
	public String postergebnis(HttpServletRequest request, Model model) {
		String input = request.getParameter("input");	// Eingabe als String

		List<Vulnerability> output = new ArrayList<Vulnerability>();

		// prüfe zuerst, ob Eingabe eine ID ist
		List<Vulnerability> ids = vulService.findAllById("\"" + input + "\"");

		// setze für gefundene Schwachstellen per ID den Score auf 100
		for (Vulnerability id : ids) {
			id.setScore(100.0);
			output.add(id);
		}

		// gebe die gefundene ID aus, fahre fort falls Eingabe keine ID war
		if (!output.isEmpty()) {
			model.addAttribute("output", output);
			return "ergebnis";
		}

		NGram ng = new NGram();
		List<Vulnerability> vulnList = vulService.getAllVuls();
		PriorityQueue<Vulnerability> prioQueue = new PriorityQueue<Vulnerability>();

		// führe den nGram Algorithmus für die Eingabe auf jede Schwachstelle in der Datenbank aus
		for (Vulnerability vulnerability : vulnList) {
			if (vulnerability.product_name != null) {
				// prüfe dabei Produktnamen und Anbieter und wähle das Maximum der beiden Scores
				double product_acc = ng.nGram(input.toLowerCase(), vulnerability.product_name.toLowerCase());
				double vendor_acc = ng.nGram(input.toLowerCase(), vulnerability.vendor_name.toLowerCase());
				double accuracy = Math.max(product_acc, vendor_acc);

				// füge die Schwachstelle in die PriorityQueue ein
				vulnerability.setScore(accuracy);
				prioQueue.add(vulnerability);
			}
		}

		int numberOfOutputs = 3;	// maximale Länge der Ausgabeliste bei Eintrgen zwischen 99 und 15 Prozent
		Vulnerability vulCheck;
		
		// füge die gefundenen Matches in die Liste ein
		while ((vulCheck = prioQueue.poll()) != null) {

			if (vulCheck.score == 100.0) {	// füge alle identischen Matches ein
				numberOfOutputs = 0;
				output.add(vulCheck);
				continue;
			} else if (numberOfOutputs == 0 || vulCheck.score < 15) {	// spring aus der Schleife, falls keine relevanten Matches mehr existieren
				break;
			} else {	// füge die Top 3 der restlichen Matches ein
				output.add(vulCheck);
				numberOfOutputs--;
			}

		}

		// Fehlerbehandlung
		if (input.equals("Fehler")) {
			return "fehler";
		}

		// keine Schwachstelle gefunden
		if (output.isEmpty()) {
			return "keinErgebnis";

		}

		if (input.equals("kein Ergebnis Detektor")) {
			return "keinErgebnisDetektor";
		}

		model.addAttribute("output", output);
		return "ergebnis";
	}

	@RequestMapping(value = "/ergebnis", method = RequestMethod.GET)
	public String ergebnis() {

		return "ergebnis";
	}

}
