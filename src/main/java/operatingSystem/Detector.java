package operatingSystem;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import resource.VulnerabilityService;
import document.Vulnerability;
import matching.AccuracyVulnerability;
import matching.NGram;

public class Detector {

	private final VulnerabilityService vulService;

	public Detector(VulnerabilityService vulService) {
		this.vulService = vulService;
	}

	// Hauptmethode des Detektors
	public List<Vulnerability> detect() throws IOException {
		
		System.out.println("_-----Methode aufgerufen!");
		
		// Herausfiltern des Betriebssystems
		String OS = System.getProperty("os.name").toLowerCase();
		List<Vulnerability> list = new ArrayList<Vulnerability>();

		// führe je nach Betriebssystem die passende Detektion aus
		if (OS.indexOf("mac") >= 0) {
			detectMac(list);
		}

		else if (OS.indexOf("win") >= 0) {
			detectWindows(list);
		}

		else if (OS.indexOf("uni") >= 0) {
			detectLinux(list);
		}

		// Filter nur die Applikationen, die einen Treffer in der DB haben
		List<Vulnerability> vuls = new ArrayList<Vulnerability>();
		List<String> vulsValue = new ArrayList<String>();
		NGram ng = new NGram();
		List<Vulnerability> vulnList = vulService.getAllVuls();

		// Berechne für jede erkannte Software den Score
		for (int i = 0; i < list.size(); i++) {
			String product_name = list.get(i).getProduct_name();

			PriorityQueue<Vulnerability> prioQueue = new PriorityQueue<Vulnerability>();	// PriorityQueue mit Score als Kriterium

			// Vergleiche für jede Schwachstelle der Datenbank die Ähnlichkeit zur erkannten Software und füge die in die Queue ein
			for (Vulnerability vulnerability : vulnList) {
				if (vulnerability.product_name != null) {
					double accuracy = ng.nGram(product_name.toLowerCase(), vulnerability.product_name.toLowerCase());
					vulnerability.setScore(accuracy);
					prioQueue.add(vulnerability);
				}
			}

			// prüfe, ob Ergebnisse mit einem Score über 15% vorhanden sind und füge Software in die Ausgabeliste hinzu, falls vorhanden
			if (prioQueue.peek() != null && prioQueue.peek().score > 15) {
				vuls.add(list.get(i));
			} else {
				continue;	// springe zur nächsten Software
			}

			int numberOfOutputs = 3;	// maximale Länge der Ausgabeliste bei Eintrgen zwischen 99 und 15 Prozent
			Vulnerability vulCheck;
			List<AccuracyVulnerability> matchingList = new ArrayList<AccuracyVulnerability>();	// Liste für die gefundenen Matches

			// füge die gefundenen Matches in die Liste ein
			while ((vulCheck = prioQueue.poll()) != null) {

				if (vulCheck.score == 100.0) {	// füge alle identischen Matches ein
					numberOfOutputs = 0;
					AccuracyVulnerability accVul = new AccuracyVulnerability(vulCheck, vulCheck.score);
					matchingList.add(accVul);
					continue;
				} else if (numberOfOutputs == 0 || vulCheck.score < 15) {	// spring aus der Schleife, falls keine relevanten Matches mehr existieren
					break;
				} else {	// füge die Top 3 der restlichen Matches ein
					AccuracyVulnerability accVul = new AccuracyVulnerability(vulCheck, vulCheck.score);
					matchingList.add(accVul);
					numberOfOutputs--;
				}

			}

			list.get(i).setMatches(matchingList);

		}

		return vuls;

	}

	// Methode zur Detektion von Mac-Geräten
	public void detectMac(List<Vulnerability> list) throws IOException {
		String[] command = { "system_profiler", "SPApplicationsDataType" };	// Befehl zum Auslesen von Mac-Geräten

		// führe den Befehl aus
		ProcessBuilder pb = new ProcessBuilder();
		pb.command(command);
		pb.directory(new File(System.getProperty("user.home")));
		pb.start();
		System.out.println("Scanning started...");
		Runtime rt = Runtime.getRuntime();
		Process pr = rt.exec(command);
		
		InputStream i = pr.getInputStream();
		InputStreamReader isr = new InputStreamReader(i);
		BufferedReader br = new BufferedReader(isr);

		Vulnerability vulOS = new Vulnerability();

		// lese Zeile für Zeile die Textdatei aus und speichere die Software als Vulnerability-Objekt
		String line;
		while ((line = br.readLine()) != null) {

			if (line.contains("Obtained from:")) {	// vendor_name hinter dem Tag Obtained from
				String temp = line;
				String temp2[] = temp.split(":");
				String vendor_name = temp2[1];
				vulOS.setVendor_name(vendor_name);
			}

			if (line.contains("Version:")) { // Version hinter dem Tag version
				String temp = line;
				String temp2[] = temp.split(":");
				String version = temp2[1];
				vulOS.setVersion(version);
			}

			if (line.contains("Location:")) { // product_name hinter dem Tag Location
				// teile den String auf, da nur der letzte Teil relevant ist
				String temp = line;
				String temp2[] = temp.split(":");
				String temp3[] = temp2[1].split("/");
				String temp4 = temp3[temp3.length - 1];
				String product_name = temp4.substring(0, temp4.length() - 4);
				vulOS.setProduct_name(product_name);

				// füge das Objekt der Liste hinzu
				Vulnerability vul = new Vulnerability();
				vul.setProduct_name(vulOS.getProduct_name());
				vul.setVendor_name(vulOS.getVendor_name());
				vul.setVersion(vulOS.getVersion());
				list.add(vul);
				vulOS.setProduct_name("");
				vulOS.setVendor_name("");
				vulOS.setVersion("");
				vulOS.setLastModified("");
			}
		}

		System.out.println("---finished");
	}

	// Methode zur Detektion von Windows-Geräten
	public void detectWindows(List<Vulnerability> list) throws IOException {

		// Speichere product_name, vendor_name und version in separate Textdateien
		
		// Befehl zum Auslesen des Produktnamens
		Runtime.getRuntime().exec(
				"powershell -command \"Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*"
						+ " | Select-Object DisplayName | Out-File -Width 2147483647 -filepath ./AlleAppsWinName.txt\"");

		// Befehl zum Auslesen der Version
		Runtime.getRuntime().exec(
				"powershell -command \"Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*"
						+ " | Select-Object DisplayVersion | Out-File -Width 2147483647 -filepath ./AlleAppsWinVersion.txt\"");

		// Befehl zum Auslesen des Anbieters
		Runtime.getRuntime().exec(
				"powershell -command \"Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*"
						+ " | Select-Object Publisher | Out-File -Width 2147483647 -filepath ./AlleAppsWinPublisher.txt\"");

		FileReader fileReaderName = new FileReader("AlleAppsWinName.txt");
		BufferedReader bufferedReaderName = new BufferedReader(fileReaderName);

		FileReader fileReaderPublisher = new FileReader("AlleAppsWinPublisher.txt");
		BufferedReader bufferedReaderPublisher = new BufferedReader(fileReaderPublisher);

		FileReader fileReaderVersion = new FileReader("AlleAppsWinVersion.txt");
		BufferedReader bufferedReaderVersion = new BufferedReader(fileReaderVersion);

		String name = null;
		String publisher = null;
		String version = null;
		int line = 0;

		while ((name = bufferedReaderName.readLine()) != null) {

			// überspringe die ersten 6 Header-Zeilen und leere Zeilen
			if (line < 6 || name.trim().isEmpty()) {
				bufferedReaderPublisher.readLine();
				bufferedReaderVersion.readLine();
				line++;
				continue;
			}

			// entferne überflüssige Leerzeichen nach dem auslesen
			name = removeAdditionalSpaces(name);
			publisher = bufferedReaderPublisher.readLine();
			publisher = removeAdditionalSpaces(publisher);
			version = bufferedReaderVersion.readLine();
			version = removeAdditionalSpaces(version);

			// füge Name, Anbieter und Version in die Produktliste ein
			Vulnerability vul = new Vulnerability();
			vul.setProduct_name(name);
			vul.setVendor_name(publisher);
			vul.setVersion(version);
			list.add(vul);

			line++;
		}

		bufferedReaderName.close();
		bufferedReaderPublisher.close();
		bufferedReaderVersion.close();

	}

	// Methode zur Detektion von Linux-Geräten
	public static void detectLinux(List<Vulnerability> list) throws IOException {
		
		//TODO: Nur für Ubuntu higher 14.04
		// Befehel testen! 
				
				
		// Für Live-Version auskommentieren 
		Runtime.getRuntime().exec(new String[]{"apt","list","--installed"});

		FileReader fileReaderName = new FileReader("packages.txt");
		BufferedReader br = new BufferedReader(fileReaderName);
		Vulnerability vulOS = new Vulnerability();

		String line = br.readLine();
		while ((line = br.readLine()) != null) {
			String temp = line;

			// Produktname extrahieren
			String temp2[] = temp.split("/");
			String product_name = temp2[0];
			System.out.println("--product name: " + product_name);
			vulOS.setProduct_name(product_name);

			// Version extrahieren
			String splitString[] = temp2[1].split(",");
			String temp3 = splitString[1].substring(6);
			String temp4[] = temp3.split(" ");
			String version = temp4[0];
			System.out.println("--version: " + version);
			vulOS.setVersion(version);

			// Objekt erzeugen
			Vulnerability vul = new Vulnerability();
			vul.setProduct_name(vulOS.getProduct_name());
			vul.setVersion(vulOS.getVersion());
			list.add(vul);
			vulOS.setProduct_name("");
			vulOS.setVersion("");
		}

		br.close();
		System.out.println("------Finished reading Linux Host!");

	}
	
	// Methode zum Entfernen von zusätzlichen Leerzeichen
	public String removeAdditionalSpaces(String string) {

		if (string != null) {
			for (int i = 0; i < string.length(); i++) {
				StringBuilder nameSb = new StringBuilder(string);
				nameSb.deleteCharAt(i);
				string = nameSb.toString();
			}

			string = string.replaceAll("\\s+", " ");
			string = string.substring(0, string.length() - 1);
		}

		return string;
	}

	// Main-Methode für Testzwecke
	public static void main(String[] args) throws IOException {

		System.out.println("Main() called ");
		List<Vulnerability> list = new ArrayList<Vulnerability>();
		detectLinux(list);

	}

}
